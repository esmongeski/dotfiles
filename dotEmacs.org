* Extra Plugins
** Evil
Because I am a vim user at heart.
It's possible I'll want to use https://github.com/Somelauw/evil-org-mode instead of =org-evil= someday. But I've never been *that* good at vim.
#+BEGIN_SRC emacs-lisp
  (use-package org-evil)
  (use-package evil)
  (evil-mode 1)
#+END_SRC
Change cursor to a bar in insert mode.
#+begin_src emacs-lisp
  (use-package evil-terminal-cursor-changer)
  (unless (display-graphic-p)
    (require 'evil-terminal-cursor-changer)
    (evil-terminal-cursor-changer-activate) ; or (etcc-on)
    )
  (setq evil-default-cursor (quote (t "#750000"))
        evil-visual-state-cursor '("#880000" box)
        evil-normal-state-cursor '("#750000" box)
        evil-insert-state-cursor '("#e2e222" bar)
        )

#+end_src
** Find lisp
#+begin_src emacs-lisp
  (use-package find-lisp)

#+end_src
** TODO Smartparens
Doesn't quite work yet - Maybe I'll get it going some day.
#+begin_src emacs-lisp
  ;;   (use-package smartparens)
  ;; (use-package evil-smartparens)
  ;; (add-hook 'smartparens-enabled-hook #'evil-smartparens-mode)

#+end_src
** Magit
Definitely pronounced "muh git", much like "muh queen". Certainly not "mahjit", despite what the top hat and wand would make you think.
#+begin_src emacs-lisp
  (use-package magit)
#+end_src

** Undo Tree
I could have sworn I had this installed at one point, but oh well!
#+begin_src emacs-lisp
  (use-package undo-tree)
  (global-undo-tree-mode)
  (global-set-key (kbd "C-x C-u") 'undo-tree-visualize)
  (define-key evil-ex-map "xu" 'undo-tree-visualize)
#+end_src
Force undo tree files into local emacs d.
#+begin_src emacs-lisp
  (setq undo-tree-history-directory-alist '(("." . "~/.emacs.d/undo")))
#+end_src
** Rifle
All the other deps with the funked up deps
#+begin_src emacs-lisp
  (use-package f)
  (use-package s)
  (use-package dash)
  (use-package helm-org-rifle)
#+end_src
** Nice autocompletion things
Much of this I just followed [[https://org-roam.discourse.group/t/how-to-to-get-title-of-the-target-note-working-with-inline-autocomplete-in-org-roam/782][this guide while trying to configure Roam]]
Smart parents
#+begin_src emacs-lisp
  (use-package smartparens)
  (smartparens-global-mode t)

#+end_src
Company
#+begin_src emacs-lisp
  (use-package company)
  (add-hook 'after-init-hook 'global-company-mode)
  (setq company-minimum-prefix-length 2)
  (setq company-idle-delay 0.25)
  (add-to-list 'company-backends 'company-capf)

#+end_src
Completion config
#+begin_src emacs-lisp
  (setq completion-ignore-case t)

#+end_src
** Helm
#+begin_src emacs-lisp
  (use-package helm
    :ensure t)
  (require 'helm-config)
  (setq helm-split-window-in-side-p t
        helm-move-to-line-cycle-in-source t)
  (helm-mode 1)
#+end_src
*** TODO Helm fuzzier matching
Doesn't quite work yet - I'm trying to get it so that I can fuzzy match
in helm-apropos, but despite what the internet says it is not working.
#+begin_src emacs-lisp
  ;; (use-package helm-fuzzier)
  ;; (helm-fuzzier-mode 1)

#+end_src

* Package things!
This is a bit of fumbling to try and get this all to work on a new computer from zero with minimal manual intervention.

The key is package-refresh-contents - however, it's super slow. The t argument makes it run asynchronously. This means I might have to open emacs multiple times on a new computer to get this working.

Apparently the call to package-initialize isn't always required? I don't fully understand what it does yet.
#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
  ;;(package-initialize)
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (eval-when-compile
    (require 'use-package))
#+END_SRC
Make use package always install if package is not installed.
#+begin_src emacs-lisp
  (setq use-package-always-ensure t)
#+end_src

Ubuntu specific (hopefully this doesn't break mac!) - this forces org to update to a later version.
#+BEGIN_SRC emacs-lisp
  (use-package org :ensure org-contrib :pin org)
#+END_SRC

This brings back the old "<s" shortcut for source blocks. Unfortunately it has different casing than before, but that's not worth the time to fix (probably easy though).
#+begin_src emacs-lisp
  (require 'org-tempo)
#+end_src

* Custom variables (I don't really remember what this is)
Variables - org agenda files, which will some day pull dates, but are also used for how things refile. I exclude archive.org from this list because it's huge.
#+BEGIN_SRC emacs-lisp
  (defun es/set-org-agenda-files ()
    "Define my org agenda files"
    (custom-set-variables
     '(org-agenda-files
       (cl-remove-if (lambda (k) (string-match-p "archive.org" k))
                     (append (find-lisp-find-files "~/Dropbox/org/" "\.org$")
                             (find-lisp-find-files "~/org/" "\.org$"))))
     ))
  (es/set-org-agenda-files)
#+END_SRC
Start with bullets folded and indented by default.
#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t)
  (setq org-startup-folded t)
#+END_SRC
No clue what custom-set-faces is to be honest.
#+BEGIN_SRC emacs-lisp
  (custom-set-faces
   ;; custom-set-faces was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   )
  ;; Package-Requires: ((dash "2.13.0"))
  ;; (add-to-list 'load-path "~/.emacs.d/vendor/emacs-powerline")
  ;; (require 'powerline)
  ;; (require 'cl)
#+END_SRC
Refile config. I found this on reddit, but I think this says "take the stuff from org-agenda-files and go +one+ N levels deep in the trees to find targets". It works.
#+BEGIN_SRC emacs-lisp
  (setq org-refile-targets '((nil :maxlevel . 1)
                             (org-agenda-files :maxlevel . 3)
                             ("~/Dropbox/org/stuff.org" :maxlevel . 1)
                             ("~/Dropbox/org/financeMath.org" :maxlevel . 2)
                             ("~/Dropbox/org/tList.org" :maxlevel . 1)
                             ("~/code/dotfiles/fish/fishProfile.org" :maxlevel . 3)
                             ("~/code/dotfiles/bashProfile.org" :maxlevel . 3)))
  (setq org-refile-use-outline-path 'file)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
#+END_SRC
Adding sh (bash) to babel languages so I can tangle my bash profile.
#+begin_src emacs-lisp
  (org-babel-do-load-languages 'org-babel-load-languages
                               '(
                                 (shell . t)
                                 )
                               )
  (setq org-babel-default-header-args:bash '((:tangle . "yes")))
#+end_src
* Todo/agenda customization - states and donetime/note
Ongoing thing to figure out what states I want. log-done enables timestamp +and prompts for a note+. Archive location is what you'd expect.

More details [[https://orgmode.org/manual/Tracking-TODO-state-changes.html][Here]]
#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
        '((sequence "TODO(t)" "SOMEDAY(s)" "WAITING(w)" "IN-PROGRESS(i)" "BLOCKED(l)" "|" "DONE(d)" "EXPORTED(e)" "OBSOLOTE(b)")))

  (setq org-log-done 'time)
  ;;(setq org-log-done 'note)

  (setq org-archive-location "~/Dropbox/org/archive.org::")
#+END_SRC

Custom priorities
#+BEGIN_SRC emacs-lisp
  (setq org-lowest-priority 74)
#+END_SRC

Make checkbox/todo tracking recursive so I see everything under the subtree
#+begin_src emacs-lisp
  (setq org-hierarchical-todo-statistics t)
#+end_src

Column view in org-agenda
#+begin_src emacs-lisp
  (setq org-columns-default-format-for-agenda "%80ITEM(Task) %4PRIORITY(Priority)  %10TODO(Todo Status) %17Effort(Estimated Effort){:} %CLOCKSUM(Time Spent)")
#+end_src
** Agenda Sorting
Define a custom tiebreaker for priority - I basically want A on par with within 1 day, B on par with within 2 days, etc.
#+begin_src emacs-lisp :tangle no
  (setq org-agenda-cmp-user-defined (lambda (a b) (message (org-get-priority a))))
#+end_src

Only one change from the default strategy, which is to use effort-up. The ordering on agenda is now "high priority first, low effort first, respect order of org-agenda-files".
I think the fact that all my things in "recurring.org" are habits sort of circuvents "habit-down". But I don't mind for now.
#+begin_src emacs-lisp
  (setq org-agenda-sorting-strategy
        '((agenda user-defined-up todo-state-down habit-down time-up priority-down effort-up category-keep)
          (todo priority-down category-keep)
          (tags priority-down category-keep)
          (search category-keep)))
#+end_src
** Curating todos
Org agenda todo - filter out things with dates so I schedule any dangling todos. Apparently I need all of these set - I tend to just slap dates on stuff so it'll show on the agenda,
which is good enough for me.
#+begin_src emacs-lisp
  (setq org-agenda-todo-ignore-scheduled "all")
  (setq org-agenda-todo-ignore-deadlines "all")
  (setq org-agenda-todo-ignore-timestamp "all")
  (setq org-agenda-todo-ignore-with-date "all")
  (setq org-agenda-tags-todo-honor-ignore-options t)
#+end_src
** Agenda shortcuts
Just a command to bring up agenda view
#+begin_src emacs-lisp
  (define-key global-map "\C-ca" 'org-agenda)
#+end_src
** Super Agenda
#+begin_src emacs-lisp
  (use-package org-super-agenda)
  (org-super-agenda-mode 1)
  (setq org-super-agenda-groups
        '(;; Each group has an implicit boolean OR operator between its selectors.
          (:name "Habits Overdue"
                 :and(:file-path "recurring.org" :deadline  past)
                 :and(:file-path "recurring.org" :scheduled past)
                 )
          (:name "Habits Today"
                 :and(:file-path "recurring.org" :deadline today)
                 :and(:file-path "recurring.org" :scheduled today)
                 )
          (:name "Important"
                 ;; Single arguments given alone
                 :and (:priority "A"
                                 :todo ("TODO" "IN-PROGRESS" "SOMEDAY")))
          (:name "Work stuff"
                 :and(:file-path "work.org" :todo ("TODO" "IN-PROGRESS"))
                 :and(:file-path "/Users/edwardsmongeski/org/roam" :todo ("TODO" "IN-PROGRESS")))
          (:name "EOD Routine"
                 :and(:todo "TODO" :file-path "recurring.org" :scheduled today :tag "eodroutine")
                 :and(:todo "TODO" :file-path "recurring.org" :scheduled past :tag "eodroutine")
                 )
          (:name "Work stuck"
                 :and(:file-path "work.org" :todo ("WAITING" "BLOCKED")))
          ;; Set order of multiple groups at once
          (:and(:priority<= "B"
                            ;; Show this section after "Today" and "Important", because
                            ;; their order is unspecified, defaulting to 0. Sections
                            ;; are displayed lowest-number-first.
                            :order 0
                            :todo ("TODO" "IN-PROGRESS" "SOMEDAY")))
          ;; After the last group, the agenda will display items that didn't
          ;; match any of these groups, with the default order position of 99
          (:name "Blocked"
                 :todo ("BLOCKED"))
          (:name "Future Habits"
                 :and(:file-path "recurring.org" :deadline future))
          (:name "Waiting"
                 :todo ("WAITING"))
          (:name "Done"
                 :todo ("DONE" "OBSOLETE")
                 )))
#+end_src
** Agenda evil shortcut
#+begin_src emacs-lisp
  (defun org-agenda-list-day () (interactive)
         "Wrapper for org-agenda-list that just lists a single day"
         (org-agenda-list 1)
         )
  (define-key evil-ex-map "a" 'org-agenda-list-day)
#+end_src
** Auto insert subtask tracke
Binds =:st= to "insert at end of line, append [/], C-cC-c it" for quick subtask adding.
#+begin_src emacs-lisp
  (fset 'es/append-subtask-tracker
        (kmacro-lambda-form [?A ?  ?\[ ?/ ?\] escape ?\C-c ?\C-c] 0 "%d"))

  (define-key evil-ex-map "st" 'es/append-subtask-tracker)
#+end_src
* Colors!!!! And other nice displays - change the ... to a return thingy, make nice bullet icons.
#+BEGIN_SRC emacs-lisp
  (load-theme 'manoj-dark)
  (setq org-ellipsis "⤵")
  (use-package org-bullets
    :ensure t
    :init
    (add-hook 'org-mode-hook (lambda ()
                               (org-bullets-mode 1))))
#+END_SRC
Line numbering - absolute and relative.
#+begin_src emacs-lisp
  (global-display-line-numbers-mode)
  (setq display-line-numbers-type 'relative)
#+end_src
This makes emacs figure out the max line numbers beforehand - for longer files
with thousands of lines, there is a little bump that happens when line numbers are
displayed - this fixes that.
#+begin_src emacs-lisp
  (setq display-line-numbers-width-start t)
#+end_src
** Emphasis markers
WIP - Hide emphasis markers to make things a bit prettier.
#+begin_src emacs-lisp
#+end_src
*bold* /italic/ _underline_ =literal= ~code~ +strikethrough+
* Custom Key Bindings
** Org refile
This first one is to get a different one for org-refile. I want it as C-r C-f (rf -> refile)

First thing to do is to set "C-r" as a possible prefix.
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'ring-map)
  (global-set-key (kbd "C-r") 'ring-map)
#+END_SRC

Next thing to do is to remove "C-r" from the evil map (apparently it's redo, which I never use).

Then we do the actual "C-r C-f" bind.
#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "C-r") nil)
  (global-set-key (kbd "C-r C-f") 'org-refile)
  (define-key evil-ex-map "rf" 'org-refile)
#+END_SRC

Another one - archive. I'm gonna do "C-r C-a" for "refile - archive", and because I have "C-r" as a prefix now.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-r C-a") 'org-archive-subtree)
  (define-key evil-ex-map "ra" 'org-archive-subtree)
#+END_SRC
*** Make refile work in evil insert
"C-r" is bound to something else, which I don't use, and I'd rather be able to refile in insert mode as well.
#+begin_src emacs-lisp
  (define-key evil-insert-state-map (kbd "C-r") nil)
  ;; (define-key evil-insert-state-map (kbd "C-r C-f"))

#+end_src
** Window switching
A lot of the below is from when I relied on C-[key] commands a la emacs style. Recently I'm moving to :[key][key] a la vim style since it's easier for typing. As such, a lot of the below might be obsolete, but hey, I'm too lazy to go reconcile it. Plus, some of the spots where vim command mode doesn't work (magit, agenda buffers) will still need C-w C-w.
#+begin_src emacs-lisp
  (define-key evil-ex-map "ww" 'evil-window-next)
  (define-key evil-ex-map "WW" 'evil-window-prev)
#+end_src
I use C-w C-w to switch windows a lot, but it messes me up when it
deletes a word in insert mode.
#+begin_src emacs-lisp
  (define-key evil-insert-state-map (kbd "C-w") nil)
  (define-key evil-insert-state-map (kbd "C-w C-w") 'evil-window-next)
  (define-key evil-insert-state-map (kbd "C-w w") 'evil-window-next)
#+end_src

I never really use the most recently used functionality, and would rather
have C-w C-p and C-w p just do previous window, since that makes sense to me.
#+begin_src emacs-lisp
  (define-key evil-motion-state-map (kbd "C-w C-p") 'evil-window-prev)
  (define-key evil-insert-state-map (kbd "C-w C-p") 'evil-window-prev)
  (define-key evil-insert-state-map (kbd "C-w p") 'evil-window-prev)
  (define-key evil-motion-state-map (kbd "C-w p") 'evil-window-prev)

#+end_src
*** TODO In magit, and also globally
#+begin_src emacs-lisp
  ;; (define-key magit-status-mode-map (kbd "C-w") nil)
  ;; (define-key magit-status-mode-map (kbd "C-w C-w") 'evil-window-next)
  ;; (define-key magit-status-mode-map (kbd "C-w w") 'evil-window-next)
  ;; (define-key magit-status-mode-map (kbd "C-w C-p") 'evil-window-prev)
  ;; (define-key magit-status-mode-map (kbd "C-w C-p") 'evil-window-prev)
  ;; (define-key magit-status-mode-map (kbd "C-w p") 'evil-window-prev)
  ;; (define-key magit-status-mode-map (kbd "C-w p") 'evil-window-prev)
  (setq w-keymap (make-sparse-keymap))
  (define-prefix-command 'w-keymap)
  (global-set-key (kbd "C-w") 'w-keymap)
  (define-key magit-status-mode-map (kbd "C-w") nil)
  (define-key magit-diff-mode-map (kbd "C-w") nil)
  (global-set-key (kbd "C-w C-w") 'evil-window-next)
#+end_src
** Quick reload
Make it so I can quickly reload emacs config.
#+begin_src emacs-lisp

  (defun quick-refresh-dot-emacs ()
    "Quickly reload emacs config"
    (interactive)
    (load-file user-init-file)
    )
  (global-set-key (kbd "C-r C-e") 'quick-refresh-dot-emacs)
  (define-key evil-ex-map "re" 'quick-refresh-dot-emacs)
#+end_src
** Nice little shortcut for evil mode for rifle.
#+begin_src emacs-lisp
  (define-key evil-ex-map "ri" 'helm-org-rifle-agenda-files)
#+end_src
** More agenda customization
I'll admit, there's a header further up for this, but for some reason defining this that far up breaks, and I don't really want
to figure out why =org-agenda-mode-map= isn't initiatlized up [[file:dotEmacs.org::149][here]]
#+begin_src emacs-lisp
  (define-key org-agenda-mode-map (kbd "C-w C-w") 'evil-window-next)
#+end_src
I am evil, so =:= is special. It sets tags in agenda, which I basically never want to do.
#+begin_src emacs-lisp
  (define-key org-agenda-mode-map (kbd ":") nil)

#+end_src
** Evil shortcuts for helm. Navigate buffers, command/func/var (apropos), and files with =:b=, etc.
#+begin_src emacs-lisp
  (define-key evil-ex-map "b" 'helm-buffers-list)
  (define-key evil-ex-map "c" 'helm-M-x)
  (define-key evil-ex-map "dd" 'helm-apropos)
  (define-key evil-ex-map "e" 'helm-find-files)
  (define-key evil-ex-map "t" 'org-todo)
#+end_src
** Do the Thing ex-map
Quick binding for C-cC-c using evil command mode.
#+begin_src emacs-lisp
  (fset 'do-the-thing
        (kmacro-lambda-form [?\C-c ?\C-c] 0 "%d"))

  (define-key evil-ex-map "dt" 'do-the-thing)
#+end_src
* Debugging
Trying to see what this does on startup so I can optimize my init/dotfiles.
#+begin_src emacs-lisp
  ;;(setq message-log-max t)
#+end_src

* IN-PROGRESS Notion
This is an attempt to hit the [[https://developers.notion.com/docs/getting-started][notion api]] in order to dump tasks out of org into notion.

My anticipated workflow is, while grooming my inbox, instead of refiling an item, I export it to Notion via POST.

Then I mark the item EXPORTED (custom TODO state) and archive it.

This is also the first elisp I'm writing on my own, so it's a learning experience.

Thus far I've managed to extract the todo state and map it to the todo status I use in notion.

Next, I need to format a payload with local secrets (api key) and hit the api. It looks like the preferred way to do this in emacs is [[http://tkf.github.io/emacs-request/][request.el]].
#+begin_src emacs-lisp
  (require 'org-element)
  ;; make a function that gets the org heading components as an alist mapped to the things in notion
  ;; make a function that json encodes that
  ;; make a function to call the api
  (defun org-todo-to-notion-todo (org-todo)
    "map org todo status to notion status - you should change this to fit whatever todo statuses you have"
    (plist-get '(TODO "To Do" IN-PROGRESSS "Doing" DONE "Done") (intern org-todo)))

  (defun org-heading-to-notion-json ()
    "Encode current heading as json"
    (let* ((ohc (org-heading-components))
           (todo-state (nth 2 ohc))
           (notion-todo-state (org-todo-to-notion-todo todo-state)))
      (message notion-todo-state)))

#+end_src

* Layout
#+begin_src emacs-lisp
  (defadvice org-agenda (around split-vertically activate)
    (let ((split-width-threshold 300))  ; or whatever width makes sense for you
      ad-do-it))
#+end_src

** Wrap text by default
#+begin_src emacs-lisp
  (add-hook 'text-mode-hook 'visual-line-mode)
#+end_src
* Org capture setup
Inbox directory
#+begin_src emacs-lisp
  (setq org-default-notes-file "~/Dropbox/org/inbox.org")
#+end_src
Stick backup files elsewhere. They screw up IFTTT's dropbox integration for some reason.
#+begin_src emacs-lisp
  (setq backup-directory-alist `(("." . "./.emacsSaves")))

#+end_src
Start server
#+begin_src emacs-lisp
  (load "server")
  (unless (server-running-p) (server-start))
#+end_src
Capture templates
#+begin_src emacs-lisp
  (setq org-capture-templates
        '(("p" "Personal" entry (file "~/Dropbox/org/inbox.org")
           "* TODO %?\n")
          ("w" "Work" entry (file "~/Dropbox/org/workInbox.org")
           "* TODO %?\n")
          ("t" "Things on my mind" entry (file "~/Dropbox/org/tList.org")
           "* TODO %?\n" )
          ("s" "Stuff" entry (file "~/Dropbox/org/stuff.org")
           "* TODO %?\n")))
#+end_src
* Powerline
#+begin_src emacs-lisp
  (use-package powerline-evil
    :config
    (powerline-evil-center-color-theme))

#+end_src
* Ubuntu
This is a hack because I probably have a bad config on my ubuntu machine. For some reason, ~string-empty-p~ isn't defined at runtime, but when I ~describe-function~ it, it shows up.
This breaks org-agenda. Requring ~subr-x~ at startup fixes this.
#+begin_src emacs-lisp
  (require 'subr-x)
#+end_src
Ubuntu specific (hopefully this doesn't break mac!) - this forces org to update to a later version.
#+BEGIN_SRC emacs-lisp
  (use-package org :ensure org-contrib :pin org)
#+END_SRC
More hacks to force dependencies into place, hopefully.
#+begin_src emacs-lisp
  (require 'org-macs)
#+end_src
* ODT Styles
The default styles are gross. I use google docs all day erry day. This is an ODT file that has the headers for google docs.

This seems to barf on multiline source blocks, but I don't use that for notes much, so that's ok (typically the last line
of a source block is unstyled).
#+begin_src emacs-lisp
  (setq org-odt-styles-file (concat (getenv "PATH_TO_DOTFILES_REPO") "/gdocStyles.odt"))
#+end_src
Table of contents is ugly, and google doc styles do it for you anyway (in google docs)
#+begin_src emacs-lisp
  (setq org-export-with-toc nil)
#+end_src

So this is an attempt to make people in a meeting todos, and then use todos to quickly flag who is speaking
as I'm taking notes. You can only do todo states on headers by default, so I'm using inlinetask to try and
use todo states elsewhere.

Update: Doesn't quite work the way I want, it renders kinda ugly in a huge block. If I'm indented far enough (5?)
the todo states seem to work. Keeping because this is needed for the meeting minutes stuff below.

Update: four *s seems to work to not use a header, which will work for me.
#+begin_src emacs-lisp
  (require 'org-inlinetask)
#+end_src
** Meeting minutes
[[https://lists.gnu.org/archive/html/emacs-orgmode/2019-10/msg00300.html][This]] seems interesting. Try it out.
Update - as of [2021-08-28 Sat]ish, I basically use roam for notes now,
and having roam nodes for people makes it easy to add attendees. This
was an interesting experiment, but I'm mostly not using it at this point.
#+begin_src emacs-lisp
  (require 'org)
  (require 'dash)

  (defun org-actionitems-extract-entry ()
    (-let* ((entries (org-entry-properties))
            ((&alist "ITEM" "TODO" "DEADLINE") entries))
      (list ITEM TODO DEADLINE)))

  (defun org-dblock-write:actionitems (params)
    (let ((match (or (plist-get params :match) "/+TODO")))
      (insert-before-markers "| What | Who | When |\n")
      (insert-before-markers "|-\n")
      (let* ((tasks (org-map-entries 'org-actionitems-extract-entry match))
             (rows (-map (lambda (task)
                           (->> task
                             (-map (lambda (item) (or item "")))
                             (apply 'format "| %s | %s | %s |")))
                         tasks))
             (table (string-join rows "\n")))
        (insert-before-markers table))
      (org-table-align)))

#+end_src

* Mermaid in org
https://github.com/arnm/ob-mermaid
Install this in "~/" or else!
#+begin_src emacs-lisp
  (use-package ob-mermaid)
  (setq ob-mermaid-cli-path "~/node_modules/.bin/mmdc")
#+end_src

This is what this ends up looking like. Keeping it here as an example - this
is just the thing that the [[https://mermaid-js.github.io/mermaid-live-editor/edit][mermaid live editor]] ships with.
#+begin_src mermaid :file mermaidTest.png
graph TD
    A[Christmas] -->|Get money| B(Go shopping)
    B --> C{Let me think}
    C -->|One| D[Laptop]
    C -->|Two| E[iPhone]
    C -->|Three| F[fa:fa-car Car]
#+end_src

[[file:mermaidTest.png]]

* Sensible Defaults
Use sensible defaults from the git submodule.
#+begin_src emacs-lisp
  (load-file (concat (getenv "PATH_TO_DOTFILES_REPO") "/sensible-defaults.el/sensible-defaults.el"))
  (sensible-defaults/use-all-settings)
  (sensible-defaults/use-all-keybindings)
#+end_src
* Exit hooks/config
Trim whitespace
#+begin_src emacs-lisp
  (add-hook 'write-file-hooks 'delete-trailing-whitespace)
#+end_src
Don't prompt for exit - this must be after sensible defaults, as it overwrites it.
#+begin_src emacs-lisp
  (setq confirm-kill-emacs nil)
#+end_src
* Helm
** Configure helm search - basically make everything as fuzzy as possible.
#+begin_src emacs-lisp
  (setq org-outline-path-complete-in-steps nil)
  (setq helm-completion-style 'helm-flex)
  (add-to-list 'completion-styles 'helm-flex)
  (setq helm-apropos-fuzzy-match t)
  (setq helm-locate-fuzzy-match t)
  (setq helm-mode-fuzzy-match t)
#+end_src
Override M-x
#+begin_src emacs-lisp
  (global-set-key (kbd "M-x") 'helm-M-x)
#+end_src
* Roam
** General setup and config
Probably need to change the viewer per OS.
#+begin_src emacs-lisp
  (setq org-roam-graph-executable "neato")
  (setq org-roam-db-location "~/org/roam/org-roam.db")
  (setq org-roam-graph-viewer "/usr/bin/open")
  (use-package org-roam
    :ensure t
    :init
    (setq org-roam-v2-ack t)
    :custom
    (org-roam-directory (file-truename "~/Dropbox/org/roam"))
    (org-roam-completion-everywhere t)
    :bind (("C-c n l" . org-roam-buffer-toggle)
           ("C-c n f" . org-roam-node-find)
           ("C-c n g" . org-roam-graph)
           ("C-c n i" . org-roam-node-insert)
           ("C-c n c" . org-roam-capture)
           ("C-c n d" . org-roam-dailies-capture-today)
           :map org-mode-map
           ("C-M-i" . completion-at-point))
    :config
    (org-roam-setup)
    ;; If using org-roam-protocol
    (require 'org-roam-protocol))
#+end_src
Roam ex map bindings
#+begin_src emacs-lisp
  (define-key evil-ex-map "ni" 'org-roam-node-insert)
  (define-key evil-ex-map "nf" 'org-roam-node-find)
  (define-key evil-ex-map "nb" 'org-roam-buffer-toggle)
#+end_src
Capture templates for roam
#+begin_src emacs-lisp
  (setq org-roam-capture-templates
        '(
          ("n" "normal" plain "%?"
           :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                              "#+title: ${title}")
           :unnarrowed t)
          ("f" "fun" plain "%?"
           :if-new (file+head "fun/%<%Y%m%d%H%M%S>-${slug}.org"
                              "#+title: ${title}\n#+filetags: fun\n")
           :unnarrowed t)
          ("w" "work" plain "%?"
           :if-new (file+head "work/%<%Y%m%d%H%M%S>-${slug}.org"
                              "#+title: ${title}")
           :unnarrowed t)
          ))
#+end_src
#+begin_src emacs-lisp
  (setq org-roam-node-display-template "${title:30}")

#+end_src
Synchronize cache on startup
#+begin_src emacs-lisp
  (org-roam-db-sync)
#+end_src

** Daily workflow
Dailies go here
#+begin_src emacs-lisp
  (setq org-roam-dailies-directory "daily/")
#+end_src
*** Daily linking
Workflow to link things from agenda to daily note to more intentionally curate todo list.
Taken from [[https://org-roam.discourse.group/t/daily-task-management-with-org-agenda-and-org-roam-dailies/989][this post]].

**** Get daily agenda
This doesn't quite seem to work yet - I suspect it doesn't play nice with
super agenda
#+begin_src emacs-lisp
  (setq org-agenda-custom-commands
        '(("d" "Daily schedule"
           ((agenda ""
                    ((org-agenda-span 'day)
                     (org-agenda-use-time-grid nil)
                     (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled 'deadline))))))))
  (defun as/get-daily-agenda (&optional date)
    "Return the agenda for the day as a string."
    (interactive)
    (let ((file (make-temp-file "daily-agenda" nil ".txt")))
      (org-agenda nil "d" nil)
      (when date (org-agenda-goto-date date))
      (org-agenda-write file nil nil "*Org Agenda*")
      (kill-buffer)
      (with-temp-buffer
        (insert-file-contents file)
        (goto-char (point-min))
        (kill-line 2)
        (while (re-search-forward "^  " nil t)
          (replace-match "- " nil nil))
        (buffer-string))))
#+end_src
**** Daily capture templates
This is the bit referenced above that inserts the target header as
a link into the org roam note. Pretty handy!
#+begin_src emacs-lisp
  (setq org-roam-dailies-capture-templates
        (let ((head
               (concat "#+title: %<%Y-%m-%d (%A)>\n#+startup: showall\n* Daily Overview\n"
                       "#+begin_src emacs-lisp :results value raw\n"
                       "(as/get-daily-agenda \"%<%Y-%m-%d>\")\n"
                       "#+end_src\n"
                       "* [/] Do Today\n- [ ] 1m\n- [ ] 1M\n- [ ] 1U\n- [ ] Must do chores\n** TODO\n* [/] Maybe Do Today\n* Journal\n")))
          `(("j" "journal" entry
             "* %<%H:%M> %?"
             :if-new (file+head+olp "~/org/roam/daily/%<%Y-%m-%d>.org" ,head ("Journal")))
            ("t" "do today" item
             "[ ] %a"
             :if-new (file+head+olp "~/org/roam/daily/%<%Y-%m-%d>.org" ,head ("Do Today"))
             :immediate-finish t)
            ("m" "maybe do today" item
             "[ ] %a"
             :if-new (file+head+olp "~/org/roam/daily/%<%Y-%m-%d>.org" ,head ("Maybe Do Today"))
             :immediate-finish t))))

#+end_src
Make a shortcut in org agenda to cap something.
#+begin_src emacs-lisp
  (define-key org-agenda-mode-map (kbd "c") 'org-roam-dailies-capture-today)
#+end_src
**** Open daily buffer for current day
#+begin_src emacs-lisp
  (defun es/open-daily-buffer ()
    ""
    (interactive)
    (es/set-org-agenda-files)
    (switch-to-buffer
     (find-file-noselect (concat "~/org/roam/daily/" (concat (format-time-string "%Y-%m-%d") ".org"))))
    )

  (define-key evil-ex-map "rd" 'es/open-daily-buffer)
#+end_src
